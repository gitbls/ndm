#!/usr/bin/python3

"""
ndm manages a (json-formatted) database that contains network configuration details.
The network configuration consists of network element information (DNS, DHCP, timeserver,
router, etc) and hosts. A host definition contains the device MAC address, its assigned
IP address, and other network configuration information.

ndm uses the database to build configuration files for DNS and DHCP servers.

Supported DNS and DHCP servers include:

* bind9 (DNS) and isc-dhcp-server (DHCP)
* dnsmasq (both DNS and DHCP)

Most of ndm's commands manage the database. Three commands are used to manage
the DNS/DHCP configuration files and servers:

* ndm build - Builds new configuration files from the database into a temp directory (/tmp/ndm.root)
* ndm diff - Compares the just-built configuration files with the ones running on the system
* ndm install - Installs the new configuration files from /tmp/ndm.root into the system and restarts the services 
"""

import argparse
import datetime
import json
import os
import pwd
import re
import shutil
import socket
import subprocess
import sys
import time
import uuid

def perrorexit(emsg):
    raise SystemExit(emsg)

def qdelfile(fn):
    try:
        os.remove(fn)
    except OSError:
        pass

def qrename(src, dst):
    try:
        os.rename(src, dst)
    except OSError:
        pass

def dosystem(docmd):
    r = subprocess.run(docmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    return r

def mktmpdir(pd):
    # Makes a tmp directory /tmp/ndm.{username}
    if pd.args.tmp == None:
        pd.tmp = "/tmp/ndm.{}".format(pwd.getpwuid(os.getuid())[0])
        os.makedirs(pd.tmp, mode=0o700, exist_ok=True)
    else:
        pd.tmp = pd.args.tmp
    
def ipinvert(ipaddr):
    # Invert 3 IP address octets
    els = ipaddr.split(".")
    return '.'.join([els[2], els[1], els[0]])
    
def getmyipaddr(ifname):
    import fcntl
    import struct
    #FM!
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        ipaddr = socket.inet_ntoa(fcntl.ioctl(
            s.fileno(),
            0x8915,  # SIOCGIFADDR
            struct.pack('256s', ifname[:15].encode('ascii') )
        )[20:24])
    except:
        ipaddr = ""
    return ipaddr

def listnormal(thestring, sepchar):
    # Normalize a list in a string to be a list of items separated by the given seperator character
    s1 = re.sub(' +', ' ', thestring.strip())  # Replace multiple spaces with a single space
    outstring = sepchar.join(s1.split(','))
    if outstring == thestring: outstring = sepchar.join(s1.split(' '))
    return re.sub(' +', ' ', outstring.strip())  # Replace multiple spaces with a single space (again, just to be sure ;)


def mkbakfn(fn):
    return "{}.bak".format(fn)

def mktmpfn(tmpdir, fn):
    # Build full filename string /tmp/ndm.{username}/fn
    return "{}/{}".format(tmpdir, os.path.basename(fn))

def printhost(pd, keyname, hname, printfmt):
    print(printfmt.format(keyname, pd.db['hosts'][keyname]['hostname'][hname]['macaddr'],\
                          hname, pd.db['hosts'][keyname]['hostname'][hname]['flags'],\
                          pd.db['hosts'][keyname]['hostname'][hname]['note'], pd.db['hosts'][keyname]['dhcphostopt']))
    
def printnode(pd, keyname, printfmt):
    # keyname is an IP address (normal) or a hostname (if CNAME)
    # If an IP address, print all the hosts that have this IP address
    if keyname in pd.db['hosts']:
        for hname in sorted(pd.db['hosts'][keyname]['hostname']):
            printhost(pd, keyname, hname, printfmt)
    else:
        if keyname in pd.db['cname']:
            for hname in sorted(pd.db['cname'][keyname]['hostname']):
                print(printfmt.format(keyname, hname, "", "+cname", "", ""))

def dodiff(pd, fnm):
    # fnm is full file spec of file in the file system
    print("*** <<{} | {}>> ***\n".format(fnm, mktmpfn(pd.tmp, fnm)))
    r = dosystem("diff {} {}".format(fnm, mktmpfn(pd.tmp, fnm)))
    # diff returns: 0:identical, 1:different, 2:trouble
    rs = r.stdout if (r.returncode == 0) or (r.returncode == 1) else r.stderr
    for line in rs.decode('utf-8').split("\n"):
        print(line)
    return True

def loadmodule(pd, modname, dnsordhcp):
    # Loads modname and instantiates the class
    # Done this way to avoid scoping issues
    try:
        # Load the module
        exec("from {} import ndm{}".format(modname, dnsordhcp))
    except (ModuleNotFoundError, ImportError, Exception) as X:
        perrorexit("? Error importing '{}' for {}\n  {}".format(modname,dnsordhcp.upper(), X))
    # Instantiate the class ndm{dns|dhcp} into pd.{dns|dhcp}
    try:
        exec("pd.{} = ndm{}(pd)".format(dnsordhcp, dnsordhcp))
    except Exception as X:
        perrorexit("? Error instantiating class 'ndm{}' in file {} for {}\n {}".format(dnsordhcp, modname, dnsordhcp.upper(),X))

def  cknownos(pd):
    if not pd.db['cfg']['os'] in pd.knownos: perrorexit("? ndm doesn't support OS '{}' for this command\n 'sudo ndm config --os type' to set".format(pd.db['cfg']['os']))
    
class pdat:
    def __init__(self):
        self.version = "V2.5"
        self.dbversion = "2"
        self.dns = None
        self.dhcp = None
        self.args = None
        self.myuuid = 0
        self.ndmcmd = ""
        self.os = ""         #Runtime coding shortcut
        self.parser = None
        self.tmp = "/tmp"
        self.configfile = ""
        self.defaultconfigfile = "/etc/dbndm.json"
        self.db = None
        self.dbmodified = False
        self.dnsmasqfh = None
        # These functions available to ndmdns and ndmdhcp classes 
        self.xqdelfile = qdelfile
        self.xdosystem = dosystem
        self.xqrename = qrename
        self.xcopy = shutil.copy
        self.xmktmpfn = mktmpfn
        self.xipinvert = ipinvert
        self.xmkbakfn = mkbakfn
        self.xperrorexit = perrorexit
        
        self.listformat = "{:<16} {:<17} {:<16} {:<16} {:<16} {}"
        self.dbinitialize = '{"cfg":{"bindoptions":"", "dbversion":"","dns":"", "dhcp":"", "os":"", "domain":"me", "subnet":"", "internals":"",\
        "subnetmask":"", "gateway":"", "timeserver":"", "dnsip":"", "dnsfqdn":"", "mxfqdn":"", "dhcplease":"86400",\
        "dhcpsubnet":"","dnslistenport":"53", "myip":"", "netdev":"eth0", "externaldns":"", "hostfqdn":"",\
        "blockdomains":"", "dnsinclude":"", "dhcpinclude":"", "dhcpglobalopt":"", "dhcphostopt":{}},"hosts":{},"cname":{}}'
        self.defaulthosts = {"127.0.0.1":"localhost", "::1":"localhost ipv6-localhost ipv6loopback",\
                             "fe00::0":"ipv6-localnet", "ff00::0":"ipv6-mcastprefix",\
                             "ff02::1":"ipv6-allnodes", "ff02::2":"ipv6-allrouters", "ff02::3":"ipv6-allhosts"}
        self.knownos = { 'raspbian', 'raspios' , 'ubuntu', 'debian' } # 'centos' not complete
        # "servicename":"python module name", Loaded at start of command execution
        self.knowndns = { "bind":"ndmdnsbind", "dnsmasq":"ndmdnsmasq" }
        self.knowndhcp = { "isc-dhcp-server":"ndmdhcpisc", "dnsmasq":"ndmdnsmasq", "none":"ndmdhcpnone" }

    def _ckconfig(self):
        # OK if these VV options are not set. All others must be set
        ignore = ['dhcphostopt', 'dhcpglobalopt', 'hostfqdn', 'dnsip', 'blockdomains', 'bindoptions', 'subnetmask', 'dnsinclude', 'dhcpinclude', 'internals']
        missing = ""
        for i in self.db['cfg']:
            if not i in ignore:
                if self.db['cfg'][i] == "":
                    if missing != "":
                        missing += ', ' + i
                    else:
                        missing = i
        if missing != "": perrorexit("? Configuration incomplete: {}\n  Use 'sudo ndm config' to define missing items".format(missing))

    def dbaddhost(self, eipaddr, emac, edhcphostopt, ehost, eopts, enote):
        if "cname" in eopts:
            if not eipaddr in self.db['cname']:
                self.db['cname'][eipaddr] = {'hostname':{ehost:{}}}
            else:
                self.db['cname'][eipaddr]['hostname'][ehost] = {}
        else:
            if not eipaddr in self.db['hosts']:
                self.db['hosts'][eipaddr] = {'hostname':{ehost:{'macaddr':emac, 'flags':eopts, 'note':enote}}, 'dhcphostopt':edhcphostopt }
            else:
                self.db['hosts'][eipaddr]['hostname'][ehost] = {'macaddr':emac, 'flags':eopts, 'note':enote}
        self.dbmodified = True

    def dbread(self, ckcfg=True):
        self.configfile =  self.args.db if self.args.db != None else self.defaultconfigfile
        if not self.configfile.endswith(".json"):
            self.configfile = "{}.json".format(self.configfile)

        if self.args.create:
            if os.path.isfile(self.configfile): perrorexit("? ndm configuration database {} already exists".format(self.configfile))
            self.db = json.loads(self.dbinitialize)
            for ip in self.defaulthosts: self.dbaddhost(ip, "", "", self.defaulthosts[ip],"+hostsonly+nodomain", "")
            self.db['cfg']['dbversion'] = self.dbversion
            self.dbmodified = True
        else:
            try:
                with open(self.configfile, 'r') as dbf:
                    try:
                        self.db = json.load(dbf)
                    except ValueError:
                        perrorexit("? ndm configuration database '{}' has invalid syntax".format(self.configfile))
            except:
                perrorexit("? Unable to open ndm configuration database '{}'\n  Use 'sudo ndm config --create' to create it".format(self.configfile))
        if ckcfg: self._ckconfig()
        #
        # Database V2 upgrade if needed
        #  * Set default DHCP and DNS services if none configured
        #  * Add dnsinclude and copy from bindinclude if present
        #  * Delete bindinclude
        #  * Change externaldns to space-separated list
        #
        if not 'version' in self.db['cfg']:
            self.db['cfg']['version'] = self.version
            self.db['cfg']['hostname'] = socket.gethostname()
            self.db['cfg']['dns'] = "bind"            #Upgrade, so set these to what they should be
            self.db['cfg']['dhcp'] = "isc-dhcp-server"
            if not 'dnsinclude' in self.db['cfg']: self.db['cfg']['dnsinclude'] = self.db['cfg']['bindinclude']
            if 'bindinclude' in self.db['cfg']: del(self.db['cfg']['bindinclude'])
            if 'servicewait' in self.db['cfg']: del(self.db['cfg']['servicewait'])
            pd.db['cfg']['externaldns'] = listnormal(pd.db['cfg']['externaldns'], " ") # Change to space-separated list
            self.db['cfg']['netdev'] = "eth0"
            self.dbmodified = True
            
        #
        # "Rename" 'dhcpkey' to DNSUpdateKey
        #
        if 'dhcpkey' in self.db['cfg']:
            self.db['cfg']['DNSUpdateKey'] = self.db['cfg']['dhcpkey']
            del(self.db['cfg']['dhcpkey'])
            self.dbmodified = True
        #
        # Make sure bindoptions key is present
        #
        if not 'bindoptions' in self.db['cfg']:
            self.db['cfg']['bindoptions'] = ""
            self.dbmodified = True
        #
        # Do best-guess OS detection. Validity checked when needed (diff, install)
        #
        if self.db['cfg']['os'] == "":
            ostype = ""
            try:
                with open("/etc/os-release") as f:
                    for line in f:
                        els = line.split('=')
                        if els[0] == "ID":
                            ostype = els[1].rstrip()
                            break
            except:
                ostype = ""
            ostype = ostype.replace('"','').lower()
            if ostype == "raspbian": ostype = "raspios"
            pd.db['cfg']['os'] = ostype
            
        #
        # Put something in subnetmask
        #
        if self.db['cfg']['subnetmask'] == "": self.db['cfg']['subnetmask'] = "/24"
        if self.db['cfg']['hostname'] == "": self.db['cfg']['hostname'] = socket.gethostname()
        if self.db['cfg']['hostfqdn'] == "":
            hostfqdn = socket.getfqdn()
            if hostfqdn != self.db['cfg']['hostname']: # ne if we got a real fqdn
                self.db['cfg']['hostfqdn'] = hostfqdn
                self.dbmodified = True
        try:
            if self.db['cfg']['myip'] == "":
                if self.args.myip != None: self.db['cfg']['myip'] = self.args.myip
                if self.db['cfg']['myip'] == "": self.db['cfg']['myip'] = getmyipaddr(self.db['cfg']['netdev'])
        except:
            self.db['cfg']['myip'] = "127.0.0.1"
        if self.db['cfg']['myip'].startswith("127.0"):
            perrorexit("% Cannot get our IP address; please use 'sudo ndm config --create --myip my.ip.ad.dr'")
        if self.db['cfg']['subnet'] == "":
            ips = self.db['cfg']['myip'].split(".")
            self.db['cfg']['subnet'] = '.'.join([ips[0], ips[1], ips[2]])
            self.dbmodified = True
        # If my MAC address ever comes out wrong, this magic is the cause!
        if self.args.create: self.dbaddhost(self.db['cfg']['myip'],\
                                ':'.join(['{:02x}'.format((uuid.getnode() >> ele) & 0xff) for ele in range(0,8*6,8)][::-1]),\
                                "", self.db['cfg']['hostname'], "", "")
        if (self.db['cfg']['dnsip'] == "") or (self.db['cfg']['dnsip'].startswith("127.0")):
            self.db['cfg']['dnsip'] = self.db['cfg']['myip']
            self.dbmodified = True

    def dbwrite(self):
        if not self.dbmodified: return True
        # Don't use mktmpfn...goes to tmp directory
        tmpf = "{}.tmp".format(self.configfile)
        bakf = mkbakfn(self.configfile)
        try:
            with open(tmpf, 'w') as dbf:
                json.dump(self.db, dbf, indent=4, sort_keys=True)
                dbf.write("\n") #Final eol
        except:
            perrorexit("? Error writing '{}'".format(tmpf))
        qdelfile(bakf)
        qrename(self.configfile, bakf)
        qrename(tmpf, self.configfile)
        self.dbmodified = False

    def dbimport(self):
        try:
            ifl = open(self.args.importnet, 'r')
        except:
            perrorexit("? Cannot find import file '{}'".format(self.args.importnet))
        hostsadded = 0
        for line in ifl:
            if line.split('#')[0] == "": continue        # ignore comment lines
            if "CONFIG=" in line:
                els = line.rstrip().split('=')
                self.db = json.loads(els[1])
                if not 'hosts' in self.db: self.db['hosts'] = {}
                if not 'cname' in self.db: self.db['cname'] = {}
            else:
                line = "{},,,,,".format(line.split('#')[0].rstrip()) # Extra commas guard against missing stuff on line
                # Split and get parts: IPAddr[0], macaddr[1], hostname[2], flags[3], note[4], dhcphostopt[5]
                els = line.split(',')
                hostsadded += 1
                self.dbaddhost(els[0], els[1], els[5], els[2].lower(), els[3], els[4])
                if self.args.verbose: printhost(pd, els[0], els[2], self.listformat)
        ifl.close()
        print("% Added/updated {} hosts".format(hostsadded))
        return True

    def dbfindhost(self, hostname):
        # Only looks at hosts, not CNAMEs
        for ip in self.db['hosts']:
            if hostname in self.db['hosts'][ip]['hostname']:
                return ip
        return ""

    def dbdoallnodes(self, dofunc, listfmt):
        lowoct = []
        for keyname in self.db['hosts']:
            if self.db['cfg']['subnet'] in keyname:
                j = int(keyname.split(".")[3])
                if not j in lowoct: lowoct.append(j)
        # Do the addresses in the subnet
        for i in sorted(lowoct):
            keyname = "{}.{}".format(self.db['cfg']['subnet'], i)
            dofunc(self, keyname, listfmt)
        # Do not-in-our-subnet addresses, etc.
        for keyname in sorted(self.db['hosts']):
            if not self.db['cfg']['subnet'] in keyname:
                dofunc(self, keyname, listfmt)
        # Do CNAMEs
        for keyname in sorted(self.db['cname']):
            dofunc(self, keyname, self.listformat)
        return True

def getmodifyhostname(pd, keyname, hname, withwhat):
    if len(pd.db['hosts'][keyname]['hostname']) > 1:
        s1 = "" if withwhat == "" else "with {}".format(withwhat)
        if hname == "": perrorexit("? '{}' has multiple hosts; --hostname must be specified {}".format(keyname, s1))
        if not hname in pd.db['hosts'][keyname]['hostname']: perrorexit("? Hostname '{}' is not assigned to IP {}".format(hname, keyname))
        return hname
    else:
        return list(pd.db['hosts'][keyname]['hostname'].keys())[0] #Fetch solitary hostname

def cmd_add(pd):
    keyname = pd.args.ip
    if keyname is None: perrorexit("? IP address must be provided")
    if pd.args.hostname is None: perrorexit("? --hostname must be provided")
    pd.args.hostname = pd.args.hostname.lower()
    theip = pd.dbfindhost(pd.args.hostname)
    if theip != "": perrorexit("? Hostname '{}' is already assigned to IP '{}'".format(pd.args.hostname, theip))
    eopts = ""
    if pd.args.nodhcp: eopts += "+nodhcp"
    if pd.args.dhcponly: eopts += "+dhcponly"
    if pd.args.hostsonly: eopts += "+hostsonly"
    if pd.args.zoneonly: eopts += "+zoneonly"
    if pd.args.cname: eopts += "+cname+zoneonly"
    if pd.args.nodomain: eopts += "+nodomain"
    if pd.args.note == None: pd.args.note = ""
    if pd.args.dhcphostopt == None: pd.args.dhcphostopt = ""
    if pd.args.mac == None: pd.args.mac = ""
    pd.dbaddhost(eipaddr=keyname, emac=pd.args.mac, edhcphostopt=pd.args.dhcphostopt,\
                 ehost=pd.args.hostname, eopts=eopts, enote=pd.args.note)
    pd.dbwrite()
    return True

def buildoutputhost(pd, keyname, listfmt):
    # Called by dbdoallnodes for each host
    # Calls the DNS and DHCP host output for each one
    if keyname in pd.db['hosts']:
        for hn in pd.db['hosts'][keyname]['hostname']:
            pd.dns.emithost(keyname, hn)
            pd.dhcp.emithost(keyname, hn)
    else:
        if keyname in pd.db['cname']:
            for hname in sorted(pd.db['cname'][keyname]['hostname']):
                pd.dns.emitcname(keyname, hname)

def cmd_build(pd):
#    cknownos(pd)
    if pd.db['cfg']['subnet'] == "":
        perrorexit("? Subnet not set; use {} --config --subnet nn.nn.nn".format(pd.ndmcmd))
    # Enables build command settings to override config
    if pd.args.dnsinclude != None:
        svdnsincl = pd.db['cfg']['dnsinclude'] 
        pd.db['cfg']['dnsinclude'] = pd.args.dnsinclude
    if pd.args.dhcpinclude != None:
        svdhcpincl = pd.db['cfg']['dhcpinclude']
        pd.db['cfg']['dhcpinclude'] = pd.args.dhcpinclude
    pd.dns.prebuild()
    pd.dhcp.prebuild()
    pd.dns.startbuild()
    pd.dhcp.startbuild()
    pd.dbdoallnodes(buildoutputhost, "")
    pd.dns.endbuild()
    pd.dhcp.endbuild()
    # Reset dnsinclude and dhcpinclude if modified, in case the DB gets written. Ugly
    if pd.args.dnsinclude != None: pd.db['cfg']['dnsinclude'] = svdnsincl
    if pd.args.dhcpinclude != None: pd.db['cfg']['dhcpinclude'] = svdhcpincl
    pd.dbwrite()         # Check and Write DB in case DNSUpdateKey was generated
    print("% Build completed in tmp directory '{}'".format(pd.tmp))
    return True

def doconfigitem(pd, dest, argval, lowerit=False):
    # If arg was specified on command line, set it into the configuration and set dbmodified
    # if lowerit=True set the value lower-cased
    if argval != None:
        pd.db['cfg'][dest] = argval if lower == False else argval.lower()
        pd.dbmodified = True

def cmd_config(pd):
    if pd.args.domain != None:
        pdom = pd.db['cfg']['domain']
        doconfigitem(pd, 'domain', pd.args.domain, lowerit=True)
        for cf in ['hostfqdn', 'dnsfqdn', 'mxfqdn']:
            fqdn = pd.db['cfg'][cf]
            if fqdn.endswith(".{}".format(pdom)):
                pd.db['cfg'][cf] = "{}.{}".format(fqdn.split(".{}".format(pdom))[0], pd.db['cfg']['domain'])
    if pd.args.subnet != None:
        sn = pd.args.subnet.split('/')
        if len(sn) > 1:
            if sn[1] != "":
                if sn[1] != "24":
                    perrorexit("? Only /24 networks currently supported")
                pd.db['cfg']['subnetmask'] = sn[1] # Needs more work
        pd.db['cfg']['subnet'] = sn[0]

    if pd.args.bindoptions != None:
        if pd.args.bindoptions != "" and not os.path.isfile(pd.args.bindoptions):
            perrorexit("? --bindoptions file '{}' not found".format(pd.args.bindoptions))
        doconfigitem(pd, 'bindoptions', pd.args.bindoptions)

    doconfigitem(pd, 'blockdomains', pd.args.blockdomains, lowerit=True)
    doconfigitem(pd, 'dhcpglobalopt', pd.args.dhcpglobalopt)
    doconfigitem(pd, 'dhcpinclude', pd.args.dhcpinclude)
    doconfigitem(pd, 'dhcplease', pd.args.dhcplease)
    doconfigitem(pd, 'dhcpsubnet', pd.args.dhcpsubnet)
    doconfigitem(pd, 'dnsfqdn', pd.args.dnsfqdn, lowerit=True)
    doconfigitem(pd, 'dnsinclude', pd.args.dnsinclude)
    doconfigitem(pd, 'dnsip', pd.args.dnsip)
    doconfigitem(pd, 'dnslistenport', pd.args.dnslistenport)
    doconfigitem(pd, 'externaldns', pd.args.externaldns)
    doconfigitem(pd, 'gateway', pd.args.gateway)
    doconfigitem(pd, 'hostfqdn', pd.args.hostfqdn, lowerit=True)
    doconfigitem(pd, 'hostname', pd.args.hostname, lowerit=True)
    doconfigitem(pd, 'internals', pd.args.internals)
    doconfigitem(pd, 'mxfqdn', pd.args.mxfqdn, lowerit=True)
    doconfigitem(pd, 'myip', pd.args.myip)
    doconfigitem(pd, 'netdev', pd.args.netdev)
    doconfigitem(pd, 'os', pd.args.os)
    doconfigitem(pd, 'timeserver', pd.args.timeserver)
    
    if pd.args.dns != None:
        if not pd.args.dns in pd.knowndns:
            perrorexit("? Unknown DNS server '{}'".format(pd.args.dns))
        doconfigitem(pd, 'dns', pd.args.dns, lowerit=True)
    if pd.args.dhcp != None:
        if not pd.args.dhcp in pd.knowndhcp:
            perrorexit("? Unknown DHCP server '{}'".format(pd.args.dhcp))
        doconfigitem(pd, 'dhcp', pd.args.dhcp, lowerit=True)
    if pd.args.dns != None or pd.args.dhcp != None:
        if pd.db['cfg']['dns'] == "dnsmasq" or pd.db['cfg']['dhcp'] == "dnsmasq":
            pd.db['cfg']['dns'] = "dnsmasq"
            if pd.args.dhcp != "none":
                pd.db['cfg']['dhcp'] = "dnsmasq"
                print("% dnsmasq will be used for both DNS and DHCP")

    if pd.args.hostfqdn == None and pd.db['cfg']['domain'] != None:
        pd.db['cfg']['hostfqdn'] = "{}.{}".format(pd.db['cfg']['hostname'],pd.db['cfg']['domain'])
        if pd.db['cfg']['dnsfqdn'] == "": pd.db['cfg']['dnsfqdn'] = pd.db['cfg']['hostfqdn']
        if pd.db['cfg']['mxfqdn'] == "": pd.db['cfg']['mxfqdn'] = pd.db['cfg']['hostfqdn']

    if pd.args.dhcphostopt != None:
        els = pd.args.dhcphostopt.split("=")
        if els[1] == "":
            del(pd.db['cfg']['dhcphostopt'][els[0]])
        else:
            pd.db['cfg']['dhcphostopt'][els[0]] = els[1]

    # Normalize externaldns and dhcpsubnet strings
    if pd.db['cfg']['externaldns'] != "": pd.db['cfg']['externaldns'] = listnormal(pd.db['cfg']['externaldns'], " ")
    if pd.db['cfg']['dhcpsubnet'] != "":  pd.db['cfg']['dhcpsubnet'] = listnormal(pd.db['cfg']['dhcpsubnet'],   " ")

    if not pd.dbmodified and (pd.args.importnet == None): pd.args.list = True
    if pd.args.importnet != None:
        pd.dbimport()
    elif pd.args.list:
        for i in sorted(pd.db['cfg']):
            if i != 'dhcphostopt': print("{:<15} {}".format(i, pd.db['cfg'][i]))
            
        if len(pd.db['cfg']['dhcphostopt']) > 0:
            print("DHCP per-host options")
            for i in pd.db['cfg']['dhcphostopt']:
                print("  {:<10} {}".format(i, pd.db['cfg']['dhcphostopt'][i]))
    pd.dbwrite()
    return True
    
def cmd_delete(pd):
    keyname = pd.args.ip
    if keyname is None: perrorexit("? No IP address specified")
    if keyname in pd.db['hosts']:
        if pd.args.hostname != None:
            # Delete a single hostname from an IP address
            if not pd.args.hostname in pd.db['hosts'][keyname]['hostname']: perrorexit("? Hostname {} not found on IP address {}".format(pd.args.hostname, keyname))
            if len(pd.db['hosts'][keyname]['hostname']) > 1:
                print("% Deleting host '{}' from IP address '{}'".format(pd.args.hostname, keyname))
                del pd.db['hosts'][keyname]['hostname'][pd.args.hostname]
            else:
                print("% Deleting IP address '{}'".format(keyname))
                del pd.db['hosts'][keyname]
        else:
            print("% Deleting IP address '{}'".format(keyname))
            del pd.db['hosts'][keyname]
    else:
        if keyname in pd.db['cname']:
            print("% Deleting CNAME '{}'".format(keyname))
            del pd.db['cname'][keyname]
        else:
            perrorexit("? IP address '{}' is not in the database".format(keyname))
    pd.dbmodified = True
    pd.dbwrite()
    return True
    
def cmd_diff(pd):
    cknownos(pd)
    pd.dns.diff(dodiff)
    pd.dhcp.diff(dodiff)
    
def cmd_install(pd):
    if pd.myuid != 0: perrorexit("? You must be root to Install")
    cknownos(pd)
    dnsrunning = pd.dns.isrunning() == 0
    dhcprunning = pd.dhcp.isrunning() == 0
    fnm = pd.dns.preinstall()
    fnm = "{} {}".format(fnm, pd.dhcp.preinstall())  # fnm=" " if all is well
    if fnm != " ":
        print("? Missing configuration files in '{}':".format(pd.tmp))
        for fn in fnm.split(" "):
            if fn != "": print("  {}".format(fn))
        perrorexit("? Please 'sudo {} build' first".format(pd.ndmcmd))
    pd.dns.stop()
    pd.dhcp.stop()
    if pd.args.reset:
        # Full Reset: Delete dynamic dns jnl files and dhcp lease files
        pd.dns.resetdyndb()
        pd.dhcp.resetdyndb()
    pd.dns.install()
    pd.dhcp.install()
    if dnsrunning: pd.dns.start()
    if dhcprunning: pd.dhcp.start()
    return True
    
def cmd_list(pd):
    if pd.args.dump:
        cfg = json.dumps(pd.db['cfg'])
        print('CONFIG={{"cfg":{}}}'.format(cfg))
    listfmt = "{},{},{},{},{},{}," if pd.args.dump else pd.listformat
    pd.dbdoallnodes(printnode, listfmt)
    return True
    
def cmd_modify(pd):
    keyname = pd.args.ip
    if keyname is None: perrorexit("? --ip must be provided")
    if not keyname in pd.db['hosts']: perrorexit("? IP address {} is not in the database".format(keyname))
    newname = pd.args.newhostname.lower() if pd.args.newhostname != None else ""
    hname = pd.args.hostname.lower() if pd.args.hostname != None else ""
    if newname != "":
        hname = getmodifyhostname(pd, keyname, hname, "renaming a host")
        theip = pd.dbfindhost(newname)
        if theip != "":  perrorexit("? Hostname '{}' is already assigned to IP '{}'".format(newname, theip))
        # Create new hostname (and copy flags, MAC Address, and note), and then delete the old one
        pd.db['hosts'][keyname]['hostname'][newname] = {'flags':pd.db['hosts'][keyname]['hostname'][hname]['flags'],\
                                                        'macaddr':pd.db['hosts'][keyname]['hostname'][hname]['macaddr'],\
                                                        'note':pd.db['hosts'][keyname]['hostname'][hname]['note']}
        del(pd.db['hosts'][keyname]['hostname'][hname])
        hname = newname
    if pd.args.note != None:
        hname = getmodifyhostname(pd, keyname, hname, "--note")
        pd.db['hosts'][keyname]['hostname'][hname]['note'] = pd.args.note
    if pd.args.mac != None:
        hname = getmodifyhostname(pd, keyname, hname, "--mac")
        pd.db['hosts'][keyname]['hostname'][hname]['macaddr'] = pd.args.mac.lower()
    if pd.args.dhcphostopt != None: pd.db['hosts'][keyname]['dhcphostopt'] = pd.args.dhcphostopt
    eopts = ""
    if pd.args.nodhcp: eopts += "+nodhcp"
    if pd.args.dhcponly: eopts += "+dhcponly"
    if pd.args.hostsonly: eopts += "+hostsonly"
    if pd.args.nodomain: eopts += "+nodomain"
    if pd.args.zoneonly: eopts += "+zoneonly"
    if eopts != "":
        hname = getmodifyhostname(pd, keyname, hname, "modifying DHCP/DNS attributes")
        pd.db['hosts'][keyname]['hostname'][hname]['flags'] = eopts
    pd.dbmodified = True
    pd.dbwrite()
    return True
    
def cmd_reip(pd):
    keyname = pd.args.ip
    if keyname is None: perrorexit("? No IP address specified")
    if keyname in pd.db['hosts']:
        newip = pd.args.newip
        if newip in pd.db['hosts']: perrorexit("? New IP Address '{}' is already in the database".format(newip))
        for hn in pd.db['hosts'][keyname]['hostname']:
            pd.dbaddhost(eipaddr=newip, emac=pd.db['hosts'][keyname]['hostname'][hn]['macaddr'], edhcphostopt=pd.db['hosts'][keyname]['dhcphostopt'],\
                    ehost=hn, eopts=pd.db['hosts'][keyname]['hostname'][hn]['flags'], enote=pd.db['hosts'][keyname]['hostname'][hn]['note'])
        del pd.db['hosts'][keyname]
    else:
        perrorexit("? IP address '{}' is not in the database".format(keyname))
    pd.dbmodified = True
    pd.dbwrite()
    return True
    
def cmd_show(pd):
    ihost = pd.args.host.lower()
    if ihost in pd.db['hosts']:         # Print specific IP address if found
        printnode(pd, ihost, pd.listformat)
    else:
        # See if a hostname,  MAC address, or hostname abbreviation specified
        for keyname in sorted(pd.db['hosts']):
            if ihost in pd.db['hosts'][keyname]['hostname']:
                printhost(pd, keyname, ihost, pd.listformat)
            else:
                for hname in sorted(pd.db['hosts'][keyname]['hostname']):
                    if ihost in pd.db['hosts'][keyname]['hostname'][hname]['macaddr']:
                        printhost(pd, keyname, hname, pd.listformat)
                    else:
                        if ihost in hname:
                            printhost(pd, keyname, hname, pd.listformat)
        # Lastly look at cnames
        for keyname in pd.db['cname']:
            if ihost in keyname:
                printnode(pd, keyname, pd.listformat)
    return True
    
def cmd_help(pd):
    xdm = pd.ndmcmd
    xnm = os.path.basename(xdm)
    print(f"\n{xnm} builds the DNS and DHCP configuration files from a database\n\
that it maintains in a JSON-formatted configuration file.\n\
\n{xnm} can build configuration files for bind (DNS), isc-dhcp-server (DHCP),\n\
dnsmasq (both DNS and DHCP), and none (no DHCP, DNS only)\n\
\n\
Use '{xdm} config --dns whichdns --dhcp whichdhcp' to configure this.\n\
\n\
Use the '{xdm} build' command to generate the service configuration files.\n\
Use the '{xdm} install' command to install the service configuration files\n\
into the system and restart the services.\n\n")
    pd.parser.print_help(None)
    print(f"\nUse '{xdm} command --help' for help on a specific command\n")

def cmd_version(pd):
    xnm = os.path.basename(pd.ndmcmd)
    xver = pd.version
    print(f"{xnm} {xver}")

#
# Initialize and parse command line
#
pd = pdat()
pd.myuid = os.getuid()
pd.ndmcmd = sys.argv[0]

pd.parser = argparse.ArgumentParser(
    description = "Build and install bind/dhcpd config files from database",
    epilog="",
    prog=os.path.basename(pd.ndmcmd),
    formatter_class=argparse.ArgumentDefaultsHelpFormatter)

pd.parser.set_defaults(func=cmd_help, ckcfg=False, create=False, db=None, loadsrv=False, mktmpdir=False, tmp=None, usedb=True)

addmodify_parent_parser = argparse.ArgumentParser(add_help=False)
addmodify_parent_parser.add_argument("--dhcponly", help="Only put this host in dhcpd.conf (no hosts or DNS config entries)", action='store_true')
addmodify_parent_parser.add_argument("--hostsonly", help="Only put this host in hosts file (no dhcpd.conf or DNS zone entries)", action='store_true')
addmodify_parent_parser.add_argument("--nodhcp", help="Don't add host to dhcpd.conf", action='store_true')
addmodify_parent_parser.add_argument("--nodomain", help="Don't add the domain name to this entry; It's already fully qualified", action='store_true')
addmodify_parent_parser.add_argument("--zoneonly", help="Only put this host in DNS config files (no dhcpd.conf or hosts file)", action='store_true')

subparsers = pd.parser.add_subparsers(help="sub-command help")

subparser_add = subparsers.add_parser("add", help="Add a new host to the database", parents=[addmodify_parent_parser])
subparser_add.add_argument("ip", help="New host IP address")
subparser_add.add_argument("--cname", help="Put this entry in DNS zone files as a CNAME", action='store_true')
subparser_add.add_argument("--db", help="Specify alternate config file")
subparser_add.add_argument("--dhcphostopt", help="Name of dhcphostopt to add to this host's dhcp entry")
subparser_add.add_argument("--hostname", help="New host name")
subparser_add.add_argument("--mac", help="MAC address for new hostname")
subparser_add.add_argument("--note", help="Note text for new hostname")
subparser_add.set_defaults(func=cmd_add)

subparser_build = subparsers.add_parser("build", help="Build new host databases in tmp staging area")
subparser_build.add_argument("--db", help="Specify alternate config file")
subparser_build.add_argument("--dhcpinclude", help="Specify an additional DHCP include file")
subparser_build.add_argument("--dnsinclude", help="Specify an additional DNS include file")
subparser_build.add_argument("--tmp", help="Directory for the the generated files")
subparser_build.set_defaults(func=cmd_build, ckcfg=True, loadsrv=True, mktmpdir=True)

subparser_config = subparsers.add_parser("config", help="Manage configuration database")
subparser_config.add_argument("--bindoptions", help="Add additional statements to bind 'options' section")
subparser_config.add_argument("--blockdomains", help="Comma-separated list of domains to block")
subparser_config.add_argument("--create", help="Create the Network DB file", action='store_true')
subparser_config.add_argument("--db", help="Specify alternate config file")
subparser_config.add_argument("--dhcpglobalopt", help="Set the global DHCP option string")
subparser_config.add_argument("--dhcpinclude", help="Specify an additional DHCP include file")
subparser_config.add_argument("--dhcphostopt", help="Set a DHCP per-host option string")
subparser_config.add_argument("--dhcplease", help="DHCP lease length in seconds [86400]")
subparser_config.add_argument("--dhcpsubnet", "--dhcprange", help="Low and High IP addresses for DHCP server pool")
subparser_config.add_argument("--dhcp", help="Specify DHCP server", choices=["dnsmasq", "isc-dhcp-server", "none"])
subparser_config.add_argument("--dns", help="Specify DNS server", choices=["bind", "dnsmasq"])
subparser_config.add_argument("--dnsfqdn", help="DNS server FQDN")
subparser_config.add_argument("--dnsinclude", help="Specify an additional DNS include file")
subparser_config.add_argument("--dnsip", help="DNS server IP address")
subparser_config.add_argument("--dnslistenport", help="Port for DNS Listen")
subparser_config.add_argument("--domain", help="Domain name")
subparser_config.add_argument("--externaldns", help="External DNS Servers")
subparser_config.add_argument("--gateway", help="Network gateway")
subparser_config.add_argument("--hostfqdn", help="My host FQDN")
subparser_config.add_argument("--hostname", help="My host nameN")
subparser_config.add_argument("--internals", help="Additional bind internals subnets from which to allow queries")
config_addil = subparser_config.add_mutually_exclusive_group()
config_addil.add_argument("--importnet", help="Import a file of hosts")
config_addil.add_argument("--list", help="Show the current configuration", action='store_true')
subparser_config.add_argument("--mxfqdn", help="Mail server FQDN")
subparser_config.add_argument("--myip", help="Specify my IP address if I need help")
subparser_config.add_argument("--netdev", help="Specify the network device [eth0]")
subparser_config.add_argument("--os", help="Specify OS type if /etc/os-release fails")
subparser_config.add_argument("--subnet", help="Network subnet")
subparser_config.add_argument("--timeserver", help="Time server IP address")
subparser_config.add_argument("--verbose", help="List each entry imported with --importnet",action='store_true')
subparser_config.set_defaults(func=cmd_config)

subparser_delete = subparsers.add_parser("delete", help="Delete a host from the database")
subparser_delete.add_argument("ip", help="IP address to delete")
subparser_delete.add_argument("--db", help="Specify alternate config file")
subparser_delete.add_argument("--hostname", help="Specify a hostname to delete from the IP address")
subparser_delete.set_defaults(func=cmd_delete)

subparser_diff = subparsers.add_parser("diff", help="Diff current and new config files")
subparser_diff.add_argument("--db", help="Specify alternate config file")
subparser_diff.add_argument("--tmp", help="Directory for the the next version files")
subparser_diff.set_defaults(func=cmd_diff, loadsrv=True, mktmpdir=True)

subparser_install = subparsers.add_parser("install", help="Install new config files into the system")
subparser_install.add_argument("--reset", help="Perform complete build/install; erase dhcp leases and reset dynamic dns", action='store_true')
subparser_install.add_argument("--db", help="Specify alternate config file")
subparser_install.add_argument("--tmp", help="Where to get the previously-generated files")
subparser_install.set_defaults(func=cmd_install, ckcfg=True, loadsrv=True, mktmpdir=True)

subparser_list = subparsers.add_parser("list", help="List the complete database")
subparser_list.add_argument("--db", help="Specify alternate config file name")
subparser_list.add_argument("--dump", help="Print list in import format", action='store_true')
subparser_list.set_defaults(func=cmd_list)

subparser_modify = subparsers.add_parser("modify", help="Modify host attributes in the database", parents=[addmodify_parent_parser])
subparser_modify.add_argument("ip", help="IP address to modify")
subparser_modify.add_argument("--db", help="Specify alternate config file name")
subparser_modify.add_argument("--dhcphostopt", help="Name of dhcphostopt to add to the host's DHCP entry")
subparser_modify.add_argument("--hostname", help="New hostname for IP address")
subparser_modify.add_argument("--mac", help="New MAC address for IP address")
subparser_modify.add_argument("--newhostname", help="New hostname")
subparser_modify.add_argument("--note", help="New note field for the host")
subparser_modify.set_defaults(func=cmd_modify)

subparser_reip = subparsers.add_parser("reip", help="Change a hosts's IP address")
subparser_reip.add_argument("ip", help="IP address to change")
subparser_reip.add_argument("--newip", help="New IP address")
subparser_reip.add_argument("--db", help="Specify alternate config file")
subparser_reip.set_defaults(func=cmd_reip)

subparser_show = subparsers.add_parser("show", help="Show a single host")
subparser_show.add_argument("host", help="Full or partial hostname/IP/MAC host to show")
subparser_show.add_argument("--db", help="Specify alternate config file name")
subparser_show.set_defaults(func=cmd_show)

subparser_version = subparsers.add_parser("version", help="Print {} version".format(pd.ndmcmd))
subparser_version.set_defaults(func=cmd_version, usedb=False)

subparser_help = subparsers.add_parser("help", help="Print help")
subparser_help.set_defaults(func=cmd_help, usedb=False) 

pd.args = pd.parser.parse_args()
if pd.args.usedb:
    pd.dbread(ckcfg=pd.args.ckcfg)
    if pd.args.mktmpdir: mktmpdir(pd)
    if pd.args.loadsrv:
        if pd.db['cfg']['dns'] != "": loadmodule(pd, pd.knowndns[pd.db['cfg']['dns']], "dns")
        if pd.db['cfg']['dhcp'] != "": loadmodule(pd, pd.knowndhcp[pd.db['cfg']['dhcp']], "dhcp")
pd.args.func(pd)
exit
